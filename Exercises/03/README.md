# Упражнение 03 - Класове и динамична памет

## Задача 1

Да се реализира клас `Song`, съдържащ следната информация:
 * име
 * изпълнител
 * жанр
 * продължителност.

Изберете подходящи типове за полетата, като имате предвид, че *име* и *изпълнител* трябва да бъдат низове,
които могат да има произволна дължина.

Имплементирайте подходящи конструктори и деструктор за класа, както и селектори и мутатори (getter-и и setter-и) за полетата.

Имплементирайте оператри за сравнение на песни, които ги сравняват на базата на тяхната продължителност, 
т.е. една песен по-малка от друга, ако дължината й е по-малка. Имплементирайте операторитe `<`, `<=`, `==`, `>=`, `>`, `!=` .

## Задача 2

Да се реализира клас `MusicAlbum`, който съдържа следните полета:
  * масив от песни, който може да има произволна дължина
  * текущ брой песни
  * текущ капацитет на албума.

За този клас да се реализират подходящи конструктори и деструктор.

Да се реализират и следните методи:
  * `void AddSong(Song song)` , който добавя `song` към масива от песни. Ако капацитетът е достигнат,
 масивът с песни да се преоразмери с подходящ нов размер, след което да се добави песента.

  * `void removeSongAtIndex(size_t index)` , който премахва от масива с песни песента, която се намира на зададения индекс.
 
  * `double totalLength() const` , който връща дължината на албума, която представлява сума от дължините на песните, които той съдържа.

  * `size_t countOfSongsOfGenre(Genre genre) const` - по даден жанр (ще приемем, че Genre e дефиниран от нас изброим тип,
 съдържащ възможните жанрове) връща боря на всички песни в този албум с дадения жанр.

  * `size_t countOfSongsOfArtist(const char* artistName) const` - връща броя на всички песни в албума,
 които са на изпълнител с даденото име. (Имайте предвид, че трябва да се проверява за съврадение на низове,
 а не за равенство между указателите към тях.)
 
  * `size_t indexOfShortestSong() const` - връща позицията на песента с най-малка продължителност в албума.
